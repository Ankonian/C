shme <nbytes> <srand> <ntrys>   

char *crashme_version = "1.1 19-SEP-1990";

/*
*  *             COPYRIGHT (c) 1990 BY             *
*   *  GEORGE J. CARRETTE, CONCORD, MASSACHUSETTS.  *
*    *             ALL RIGHTS RESERVED               *
*
*    Permission to use, copy, modify, distribute and sell this software
*    and its documentation for any purpose and without fee is hereby
*    granted, provided that the above copyright notice appear in all copies
*    and that both that copyright notice and this permission notice appear
*    in supporting documentation, and that the name of the author
*    not be used in advertising or publicity pertaining to distribution
*    of the software without specific, written prior permission.
*
*    THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
*    ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
*    HE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
*    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
*    WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
*    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
*    SOFTWARE.
*
*    A signal handler is set up so that in most cases the machine exception
*    generated by the illegal instructions, bad operands, etc in the procedure
*    made up of random data are caught; and another round of randomness may
*    be tried. Eventually a random instruction may corrupt the program or
*    the machine state in such a way that the program must halt. This is
*    a test of the robustness of the hardware/software for instruction
*    fault handling.
*
*      Note:
*      Seen to be able to crash a SUN-4/110 OS 4.1, SUN-4/280 OS 4.0.3:
*        %crashme 1000 10 200
*        Also various combinations of inputs have been reported to crash
*        other machines.
*
*        Comments may be addressed to the author at GJC@BU-IT.BU.EDU
*
*        Version Date         Description
*        ----------------------------------------------------------------------
*         1.0    early 1990   initial hack.
*          1.1    19-SEP-1990  added more signals and an alarm to abort looping.
*
*          */


#include <stdio.h>
#include <signal.h>
#include <setjmp.h>

long nbytes,nseed,ntrys;
unsigned char *the_data;

jmp_buf again_buff;

void (*badboy)();

void again_handler(sig, code, scp, addr)
int sig, code;
struct sigcontext *scp;
char *addr;
{char *ss;
  switch(sig)
  {case SIGILL: ss =   " illegal instruction"; break;
  case SIGTRAP: ss =   " trace trap"; break;
  case SIGFPE: ss =   " arithmetic exception"; break;
  case SIGBUS: ss =  " bus error"; break;
  case SIGSEGV: ss =  " segmentation violation"; break;
  case SIGIOT: ss = " IOT instruction"; break;
  case SIGEMT: ss = " EMT instruction"; break;
  case SIGALRM: ss = " alarm clock"; break;
  default: ss = "";}
  fprintf(stderr,"Got signal %d%s\n",sig,ss);
  longjmp(again_buff,3);}

  set_up_signals()
  {signal(SIGILL,again_handler);
    signal(SIGTRAP,again_handler);
    signal(SIGFPE,again_handler);
    signal(SIGBUS,again_handler);
    signal(SIGSEGV,again_handler);
    signal(SIGIOT,again_handler);
    signal(SIGEMT,again_handler);
    signal(SIGALRM,again_handler);}

    compute_badboy()
    {long j,n;
      n = (nbytes < 0) ? - nbytes : nbytes;
      for(j=0;j<n;++j) the_data[j] = (rand() >> 7) & 0xFF;
      if (nbytes < 0)
      {fprintf(stdout,"Dump of %ld bytes of data\n",n);
      for(j=0;j<n;++j)
      {fprintf(stdout,"%3d",the_data[j]);
      if ((j % 20) == 19) putc('\n',stdout); else putc(' ',stdout);}
      putc('\n',stdout);}}

      try_one_crash()
      {compute_badboy();
        if (nbytes > 0)
        (*badboy)();
        else if (nbytes == 0)
        while(1);}

        main(argc,argv)
        int argc; char **argv;
        {if (argc != 4) {fprintf(stderr,"crashme <nbytes> <srand> <ntrys>\n");
        exit(1);}
        fprintf(stdout,"Crashme: (c) Copyright 1990 George J. Carrette\n");
        fprintf(stdout,"Version: %s\n",crashme_version);
        nbytes = atol(argv[1]);
        nseed = atol(argv[2]);
        ntrys = atol(argv[3]);
        fprintf(stdout,"crashem %ld %ld %ld\n",nbytes,nseed,ntrys);
        fflush(stdout);
        the_data = (unsigned char *) malloc((nbytes < 0) ? -nbytes : nbytes);
        badboy = (void (*)()) the_data;
        fprintf(stdout,"Badboy at %d. 0x%X\n",badboy,badboy);
        srand(nseed);
        badboy_loop();}

        badboy_loop()
        {int i;
          for(i=0;i<ntrys;++i)
          {fprintf(stderr,"%ld\n",i);
          if(setjmp(again_buff) == 3)
          fprintf(stderr,"Barfed\n");
          else
          {set_up_signals();
            alarm(10);
            try_one_crash();
            fprintf(stderr,"didn't barf!\n");}}}
